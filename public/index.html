<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Series Finder (TMDB)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .clamp-4 {
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <header class="sticky top-0 z-10 backdrop-blur bg-white/75 border-b">
    <div class="max-w-7xl mx-auto px-4 py-3 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
      <h1 class="text-2xl font-bold">Series Finder</h1>
      <div class="flex flex-wrap gap-2 md:justify-end items-center text-sm">
        <input id="searchInput"
               type="search"
               placeholder="Search title or overview…"
               class="rounded-xl border px-3 py-1.5 min-w-[180px]" />
        <select id="yearFilter" class="rounded-xl border px-3 py-1.5">
          <option value="">All years</option>
        </select>
        <select id="sortBy" class="rounded-xl border px-3 py-1.5">
          <option value="original">Sort: Original order</option>
          <option value="title">Sort: Title A–Z</option>
          <option value="year">Sort: Year</option>
          <option value="rating">Sort: Rating high → low</option>
        </select>
        <button id="exportCsv" class="rounded-xl border px-3 py-1.5">
          Export CSV
        </button>
        <button id="exportJson" class="rounded-xl border px-3 py-1.5">
          Export JSON
        </button>
        <button id="toggleForm" class="rounded-xl border px-4 py-1.5">
          + Add / Edit series
        </button>
      </div>
    </div>

    <!-- Add/Edit form -->
    <div id="seriesFormWrap" class="max-w-7xl mx-auto px-4 pb-3 hidden">
      <form id="seriesForm"
            class="flex flex-wrap gap-2 items-center bg-slate-100 border rounded-xl px-3 py-2">
        <input type="hidden" id="seriesId" />
        <input id="seriesTitle"
               type="text"
               placeholder="Title"
               class="flex-1 min-w-[160px] rounded-xl border px-3 py-1" />
        <input id="seriesYear"
               type="number"
               placeholder="Year (optional)"
               class="w-28 rounded-xl border px-3 py-1" />
        <button type="submit"
                class="rounded-xl bg-slate-900 text-white px-4 py-1">
          Save
        </button>
        <button type="button"
                id="seriesCancel"
                class="rounded-xl border px-4 py-1">
          Cancel
        </button>
        <span id="seriesFormStatus"
              class="text-xs text-slate-600 ml-2"></span>
      </form>
    </div>
  </header>

  <main class="max-w-7xl mx-auto p-4">
    <p id="status" class="text-sm text-slate-600 mb-3">
      Loading series…
    </p>
    <div id="grid"
         class="grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 content-start"></div>
  </main>

  <!-- Card template -->
  <template id="cardTpl">
    <article class="rounded-2xl overflow-hidden shadow-sm border bg-white flex flex-col h-full">
      <div data-img
           class="aspect-[2/3] bg-slate-200 grid place-items-center text-slate-500 text-sm">
        Loading…
      </div>
      <div class="p-4 flex-1 flex flex-col gap-2">
        <div class="flex justify-between items-start gap-2">
          <h2 class="font-semibold text-lg leading-snug flex-1"></h2>
          <button type="button"
                  data-edit
                  class="text-xs rounded-full border px-2 py-1">
            Edit
          </button>
        </div>

        <!-- Your rating stars -->
        <div class="flex items-center gap-2 text-sm">
          <div data-rating
               class="flex items-center gap-1 text-yellow-400 text-lg"></div>
          <span data-rating-label
                class="text-xs text-slate-600"></span>
        </div>

        <p class="text-sm text-slate-600 clamp-4"></p>
        <div class="mt-1 text-xs flex flex-wrap gap-x-3 gap-y-1 text-slate-700"></div>
        <a target="_blank"
           rel="noopener"
           class="mt-auto pt-2 text-sm text-blue-600 hover:underline">
          View on TMDB →
        </a>
      </div>
    </article>
  </template>

  <script>
    // Adjust these if your Worker is on another domain / path
const API_BASE   = "https://series-backend.mobinshahidiinia.workers.dev";
const API_TMDB   = API_BASE + "/api/tmdb";
const API_SERIES = API_BASE + "/api/series";
const IMG_BASE   = "https://image.tmdb.org/t/p/w342";

    async function readSeriesList() {
      const res = await fetch(API_SERIES, { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load series list from API");
      const json = await res.json();
      return json.items || [];
    }

    const debounce = (fn, ms = 250) => {
      let t;
      return (...a) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...a), ms);
      };
    };

    async function fetchShow(title, year) {
      const url = new URL(API_TMDB, location.origin);
      url.searchParams.set("q", title);
      if (year) url.searchParams.set("year", year);
      const res = await fetch(url);
      if (!res.ok) throw new Error("TMDB lookup failed");
      return res.json();
    }

    let DATA = [];    // For export
    let SERIES = [];  // {id, title, year, rating}
    let CARD_INDEX = 0;

    function renderUserRating(container, rating) {
      container.innerHTML = "";
      for (let i = 1; i <= 5; i++) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.dataset.rate = String(i);
        btn.textContent = i <= rating ? "★" : "☆";
        btn.className = "cursor-pointer leading-none";
        container.appendChild(btn);
      }
    }

    function updateRatingLabel(labelEl, rating) {
      if (!rating || rating <= 0) {
        labelEl.textContent = "Not rated yet";
      } else {
        labelEl.textContent = `Your rating: ${rating}/5`;
      }
    }

    function mountCard(seriesItem) {
      const { id, title, year, rating = 0 } = seriesItem;
      const grid = document.getElementById("grid");
      const tpl = document.getElementById("cardTpl");
      const node = tpl.content.cloneNode(true);

      const imgWrap = node.querySelector("[data-img]");
      const h2 = node.querySelector("h2");
      const p = node.querySelector("p");
      const meta = node.querySelector("div.mt-1");
      const link = node.querySelector("a");
      const ratingContainer = node.querySelector("[data-rating]");
      const ratingLabel = node.querySelector("[data-rating-label]");
      const editBtn = node.querySelector("[data-edit]");

      h2.textContent = year ? `${title} — ${year}` : title;
      p.textContent = "Fetching…";
      link.removeAttribute("href");

      const wrapper = document.createElement("div");
      wrapper.appendChild(node);
      const cardEl = wrapper.firstElementChild;
      cardEl.dataset.seriesId = id;
      cardEl.dataset.title = title.toLowerCase();
      cardEl.dataset.year = year ? String(year) : "";
      cardEl.dataset.rating = String(rating || 0);
      cardEl.dataset.index = String(CARD_INDEX++);
      grid.appendChild(cardEl);

      // Rating UI
      renderUserRating(ratingContainer, rating || 0);
      updateRatingLabel(ratingLabel, rating || 0);

      ratingContainer.addEventListener("click", async (e) => {
        const target = e.target;
        if (!(target instanceof HTMLElement)) return;
        const value = target.dataset.rate;
        if (!value) return;

        const newRating = Number(value);
        // optimistic UI
        renderUserRating(ratingContainer, newRating);
        updateRatingLabel(ratingLabel, newRating);
        cardEl.dataset.rating = String(newRating);

        try {
          await fetch(`${API_SERIES}/${id}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ rating: newRating }),
          });

          const idx = SERIES.findIndex((s) => s.id === id);
          if (idx !== -1) SERIES[idx].rating = newRating;

          applyFiltersAndSort(); // re-rank
        } catch {
          // on error we don't revert, but you could if you want
        }
      });

      // Edit button -> fill form
      editBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const formWrap = document.getElementById("seriesFormWrap");
        const idInput = document.getElementById("seriesId");
        const titleInput = document.getElementById("seriesTitle");
        const yearInput = document.getElementById("seriesYear");
        const statusSpan = document.getElementById("seriesFormStatus");

        idInput.value = id;
        titleInput.value = title;
        yearInput.value = year || "";
        statusSpan.textContent = "Editing existing series…";
        formWrap.classList.remove("hidden");
      });

      return function update(data) {
        p.textContent = data.overview || "";
        meta.innerHTML = [
          data.name && data.name !== title
            ? `<span class="opacity-80">TMDB: ${data.name}</span>`
            : "",
          data.date ? `<span>First air: ${data.date}</span>` : "",
          data.vote_average
            ? `<span>TMDB rating: ${Number(data.vote_average).toFixed(1)}</span>`
            : "",
          data.networks?.length
            ? `<span>Networks: ${data.networks.join(", ")}</span>`
            : "",
          data.status ? `<span>Status: ${data.status}</span>` : "",
        ]
          .filter(Boolean)
          .join(" · ");

        const imgWrap = cardEl.querySelector("[data-img]");
        if (data.poster_path) {
          const img = document.createElement("img");
          img.loading = "lazy";
          img.src = IMG_BASE + data.poster_path;
          img.alt = data.name || title;
          img.className = "w-full h-auto block";
          imgWrap.innerHTML = "";
          imgWrap.appendChild(img);
        } else {
          imgWrap.textContent = "No image";
        }

        if (data.tmdbUrl) {
          link.href = data.tmdbUrl;
        }
      };
    }

    function populateYearFilter(list) {
      const years = Array.from(
        new Set(list.map((x) => x.year).filter((y) => !!y))
      ).sort((a, b) => a - b);
      const sel = document.getElementById("yearFilter");
      years.forEach((y) => {
        const o = document.createElement("option");
        o.value = String(y);
        o.textContent = y;
        sel.appendChild(o);
      });
    }

    function applyFiltersAndSort() {
      const q = document
        .getElementById("searchInput")
        .value.trim()
        .toLowerCase();
      const y = document.getElementById("yearFilter").value;
      const sortBy = document.getElementById("sortBy").value;
      const grid = document.getElementById("grid");
      const cards = Array.from(grid.children);

      // sort
      cards.sort((a, b) => {
        const ra = Number(a.dataset.rating || "0");
        const rb = Number(b.dataset.rating || "0");
        const ya = Number(a.dataset.year || "0");
        const yb = Number(b.dataset.year || "0");
        const ta = a.dataset.title || "";
        const tb = b.dataset.title || "";
        const ia = Number(a.dataset.index || "0");
        const ib = Number(b.dataset.index || "0");

        if (sortBy === "rating") {
          if (rb !== ra) return rb - ra;
          return ia - ib;
        }
        if (sortBy === "year") {
          if (yb !== ya) return yb - ya; // newer first
          return ia - ib;
        }
        if (sortBy === "title") {
          return ta.localeCompare(tb);
        }
        // original
        return ia - ib;
      });

      cards.forEach((c) => grid.appendChild(c));

      // filter
      let shown = 0;
      cards.forEach((card) => {
        const title = card.dataset.title || "";
        const year = card.dataset.year || "";
        const desc = (card.querySelector("p").textContent || "").toLowerCase();

        const matchQ = !q || title.includes(q) || desc.includes(q);
        const matchY = !y || year === y;
        const visible = matchQ && matchY;
        card.style.display = visible ? "" : "none";
        if (visible) shown++;
      });

      document.getElementById("status").textContent =
        shown + " of " + cards.length + " shown";
    }

    function exportCsv() {
      const headers = [
        "Input Title",
        "Input Year",
        "Your Rating",
        "TMDB ID",
        "TMDB Name",
        "First Air Date",
        "TMDB Rating",
        "Status",
        "Networks",
        "TMDB URL",
      ];
      const rows = DATA.map((d) => [
        d.inputTitle,
        d.inputYear,
        d.userRating ?? "",
        d.id || "",
        d.name || "",
        d.date || "",
        d.vote_average || "",
        d.status || "",
        (d.networks || []).join("; "),
        d.tmdbUrl || "",
      ]);
      const csv = [headers, ...rows]
        .map((r) =>
          r.map((v) => `"${String(v).replaceAll('"', '""')}"`).join(",")
        )
        .join("\n");
      const blob = new Blob([csv], {
        type: "text/csv;charset=utf-8;",
      });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "series.csv";
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function exportJson() {
      const subset = DATA.map(
        ({
          inputTitle,
          inputYear,
          userRating,
          id,
          name,
          date,
          vote_average,
          status,
          networks,
          tmdbUrl,
          poster_path,
        }) => ({
          inputTitle,
          inputYear,
          userRating,
          id,
          name,
          date,
          vote_average,
          status,
          networks,
          tmdbUrl,
          poster_path,
        })
      );
      const blob = new Blob([JSON.stringify(subset, null, 2)], {
        type: "application/json",
      });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "series.json";
      a.click();
      URL.revokeObjectURL(a.href);
    }

    document
      .getElementById("searchInput")
      .addEventListener("input", debounce(applyFiltersAndSort, 150));
    document
      .getElementById("yearFilter")
      .addEventListener("change", applyFiltersAndSort);
    document
      .getElementById("sortBy")
      .addEventListener("change", applyFiltersAndSort);
    document
      .getElementById("exportCsv")
      .addEventListener("click", exportCsv);
    document
      .getElementById("exportJson")
      .addEventListener("click", exportJson);

    // Form handlers
    (function initForm() {
      const toggleBtn = document.getElementById("toggleForm");
      const wrap = document.getElementById("seriesFormWrap");
      const form = document.getElementById("seriesForm");
      const idInput = document.getElementById("seriesId");
      const titleInput = document.getElementById("seriesTitle");
      const yearInput = document.getElementById("seriesYear");
      const cancelBtn = document.getElementById("seriesCancel");
      const statusSpan = document.getElementById("seriesFormStatus");

      toggleBtn.addEventListener("click", () => {
        wrap.classList.toggle("hidden");
        if (!wrap.classList.contains("hidden")) {
          statusSpan.textContent = "Add a new series";
        }
      });

      cancelBtn.addEventListener("click", () => {
        idInput.value = "";
        titleInput.value = "";
        yearInput.value = "";
        statusSpan.textContent = "";
        wrap.classList.add("hidden");
      });

      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        const id = idInput.value.trim();
        const title = titleInput.value.trim();
        const yearVal = yearInput.value.trim();
        const year = yearVal === "" ? null : Number(yearVal);

        if (!title) {
          statusSpan.textContent = "Title is required";
          return;
        }

        statusSpan.textContent = "Saving…";
        try {
          if (id) {
            await fetch(`${API_SERIES}/${id}`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title, year }),
            });
          } else {
            await fetch(API_SERIES, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title, year }),
            });
          }
          location.reload(); // easiest: reload to refresh list + TMDB data
        } catch (err) {
          statusSpan.textContent = "Error saving";
        }
      });
    })();

    // Simple concurrency pool
    async function pool(tasks, limit = 4) {
      let i = 0,
        running = 0;
      const results = [];
      return new Promise((resolve) => {
        const next = () => {
          if (i === tasks.length && running === 0) return resolve(results);
          while (running < limit && i < tasks.length) {
            const idx = i++;
            running++;
            tasks[idx]()
              .then((r) => (results[idx] = r))
              .catch(() => {})
              .finally(() => {
                running--;
                next();
              });
          }
        };
        next();
      });
    }

    // Init
    (async function init() {
      try {
        const list = await readSeriesList();
        SERIES = list;
        populateYearFilter(list);
        document.getElementById("status").textContent =
          "Loaded " + list.length + " items. Looking up on TMDB…";

        const tasks = list.map((item) => {
          const { id, title, year, rating = 0 } = item;
          const update = mountCard(item);
          return async () => {
            try {
              const data = await fetchShow(title, year);
              const row = {
                inputTitle: title,
                inputYear: year,
                userRating: rating || 0,
                ...data,
              };
              DATA.push(row);
              update(data);
              applyFiltersAndSort();
              document.getElementById("status").textContent =
                DATA.length + "/" + list.length + " fetched";
            } catch (e) {
              update({ overview: String(e) });
            }
          };
        });

        await pool(tasks, 4);
        applyFiltersAndSort();
      } catch (e) {
        document.getElementById("status").textContent =
          "Error: " + e.message;
      }
    })();
  </script>
</body>
</html>

